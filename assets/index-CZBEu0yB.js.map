{"version":3,"file":"index-CZBEu0yB.js","sources":["../../node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"],"sourcesContent":["import { fromUtf8, toUtf8 } from \"@smithy/util-utf8\";\nexport class EventStreamSerde {\n    marshaller;\n    serializer;\n    deserializer;\n    serdeContext;\n    defaultContentType;\n    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }) {\n        this.marshaller = marshaller;\n        this.serializer = serializer;\n        this.deserializer = deserializer;\n        this.serdeContext = serdeContext;\n        this.defaultContentType = defaultContentType;\n    }\n    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = requestSchema.getEventStreamMember();\n        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);\n        const serializer = this.serializer;\n        const defaultContentType = this.defaultContentType;\n        const initialRequestMarker = Symbol(\"initialRequestMarker\");\n        const eventStreamIterable = {\n            async *[Symbol.asyncIterator]() {\n                if (initialRequest) {\n                    const headers = {\n                        \":event-type\": { type: \"string\", value: \"initial-request\" },\n                        \":message-type\": { type: \"string\", value: \"event\" },\n                        \":content-type\": { type: \"string\", value: defaultContentType },\n                    };\n                    serializer.write(requestSchema, initialRequest);\n                    const body = serializer.flush();\n                    yield {\n                        [initialRequestMarker]: true,\n                        headers,\n                        body,\n                    };\n                }\n                for await (const page of eventStream) {\n                    yield page;\n                }\n            },\n        };\n        return marshaller.serialize(eventStreamIterable, (event) => {\n            if (event[initialRequestMarker]) {\n                return {\n                    headers: event.headers,\n                    body: event.body,\n                };\n            }\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);\n            const headers = {\n                \":event-type\": { type: \"string\", value: eventType },\n                \":message-type\": { type: \"string\", value: \"event\" },\n                \":content-type\": { type: \"string\", value: explicitPayloadContentType ?? defaultContentType },\n                ...additionalHeaders,\n            };\n            return {\n                headers,\n                body,\n            };\n        });\n    }\n    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {\n        const marshaller = this.marshaller;\n        const eventStreamMember = responseSchema.getEventStreamMember();\n        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);\n        const memberSchemas = unionSchema.getMemberSchemas();\n        const initialResponseMarker = Symbol(\"initialResponseMarker\");\n        const asyncIterable = marshaller.deserialize(response.body, async (event) => {\n            const unionMember = Object.keys(event).find((key) => {\n                return key !== \"__type\";\n            }) ?? \"\";\n            const body = event[unionMember].body;\n            if (unionMember === \"initial-response\") {\n                const dataObject = await this.deserializer.read(responseSchema, body);\n                delete dataObject[eventStreamMember];\n                return {\n                    [initialResponseMarker]: true,\n                    ...dataObject,\n                };\n            }\n            else if (unionMember in memberSchemas) {\n                const eventStreamSchema = memberSchemas[unionMember];\n                if (eventStreamSchema.isStructSchema()) {\n                    const out = {};\n                    let hasBindings = false;\n                    for (const [name, member] of eventStreamSchema.structIterator()) {\n                        const { eventHeader, eventPayload } = member.getMergedTraits();\n                        hasBindings = hasBindings || Boolean(eventHeader || eventPayload);\n                        if (eventPayload) {\n                            if (member.isBlobSchema()) {\n                                out[name] = body;\n                            }\n                            else if (member.isStringSchema()) {\n                                out[name] = (this.serdeContext?.utf8Encoder ?? toUtf8)(body);\n                            }\n                            else if (member.isStructSchema()) {\n                                out[name] = await this.deserializer.read(member, body);\n                            }\n                        }\n                        else if (eventHeader) {\n                            const value = event[unionMember].headers[name]?.value;\n                            if (value != null) {\n                                if (member.isNumericSchema()) {\n                                    if (value && typeof value === \"object\" && \"bytes\" in value) {\n                                        out[name] = BigInt(value.toString());\n                                    }\n                                    else {\n                                        out[name] = Number(value);\n                                    }\n                                }\n                                else {\n                                    out[name] = value;\n                                }\n                            }\n                        }\n                    }\n                    if (hasBindings) {\n                        return {\n                            [unionMember]: out,\n                        };\n                    }\n                }\n                return {\n                    [unionMember]: await this.deserializer.read(eventStreamSchema, body),\n                };\n            }\n            else {\n                return {\n                    $unknown: event,\n                };\n            }\n        });\n        const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n        const firstEvent = await asyncIterator.next();\n        if (firstEvent.done) {\n            return asyncIterable;\n        }\n        if (firstEvent.value?.[initialResponseMarker]) {\n            if (!responseSchema) {\n                throw new Error(\"@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.\");\n            }\n            for (const [key, value] of Object.entries(firstEvent.value)) {\n                initialResponseContainer[key] = value;\n            }\n        }\n        return {\n            async *[Symbol.asyncIterator]() {\n                if (!firstEvent?.value?.[initialResponseMarker]) {\n                    yield firstEvent.value;\n                }\n                while (true) {\n                    const { done, value } = await asyncIterator.next();\n                    if (done) {\n                        break;\n                    }\n                    yield value;\n                }\n            },\n        };\n    }\n    writeEventBody(unionMember, unionSchema, event) {\n        const serializer = this.serializer;\n        let eventType = unionMember;\n        let explicitPayloadMember = null;\n        let explicitPayloadContentType;\n        const isKnownSchema = (() => {\n            const struct = unionSchema.getSchema();\n            return struct[4].includes(unionMember);\n        })();\n        const additionalHeaders = {};\n        if (!isKnownSchema) {\n            const [type, value] = event[unionMember];\n            eventType = type;\n            serializer.write(15, value);\n        }\n        else {\n            const eventSchema = unionSchema.getMemberSchema(unionMember);\n            if (eventSchema.isStructSchema()) {\n                for (const [memberName, memberSchema] of eventSchema.structIterator()) {\n                    const { eventHeader, eventPayload } = memberSchema.getMergedTraits();\n                    if (eventPayload) {\n                        explicitPayloadMember = memberName;\n                    }\n                    else if (eventHeader) {\n                        const value = event[unionMember][memberName];\n                        let type = \"binary\";\n                        if (memberSchema.isNumericSchema()) {\n                            if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {\n                                type = \"integer\";\n                            }\n                            else {\n                                type = \"long\";\n                            }\n                        }\n                        else if (memberSchema.isTimestampSchema()) {\n                            type = \"timestamp\";\n                        }\n                        else if (memberSchema.isStringSchema()) {\n                            type = \"string\";\n                        }\n                        else if (memberSchema.isBooleanSchema()) {\n                            type = \"boolean\";\n                        }\n                        if (value != null) {\n                            additionalHeaders[memberName] = {\n                                type,\n                                value,\n                            };\n                            delete event[unionMember][memberName];\n                        }\n                    }\n                }\n                if (explicitPayloadMember !== null) {\n                    const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);\n                    if (payloadSchema.isBlobSchema()) {\n                        explicitPayloadContentType = \"application/octet-stream\";\n                    }\n                    else if (payloadSchema.isStringSchema()) {\n                        explicitPayloadContentType = \"text/plain\";\n                    }\n                    serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);\n                }\n                else {\n                    serializer.write(eventSchema, event[unionMember]);\n                }\n            }\n            else {\n                throw new Error(\"@smithy/core/event-streams - non-struct member not supported in event stream union.\");\n            }\n        }\n        const messageSerialization = serializer.flush();\n        const body = typeof messageSerialization === \"string\"\n            ? (this.serdeContext?.utf8Decoder ?? fromUtf8)(messageSerialization)\n            : messageSerialization;\n        return {\n            body,\n            eventType,\n            explicitPayloadContentType,\n            additionalHeaders,\n        };\n    }\n}\n"],"names":["EventStreamSerde","marshaller","serializer","deserializer","serdeContext","defaultContentType","__publicField","eventStream","requestSchema","initialRequest","eventStreamMember","unionSchema","initialRequestMarker","eventStreamIterable","headers","body","page","event","unionMember","key","additionalHeaders","eventType","explicitPayloadContentType","response","responseSchema","initialResponseContainer","memberSchemas","initialResponseMarker","asyncIterable","dataObject","eventStreamSchema","out","hasBindings","name","member","eventHeader","eventPayload","_a","toUtf8","value","_b","asyncIterator","firstEvent","done","explicitPayloadMember","isKnownSchema","eventSchema","memberName","memberSchema","type","payloadSchema","messageSerialization","fromUtf8"],"mappings":"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","x_google_ignoreList":[0]}